<?php

/**
 * An interface to a private page created by a plugin.
 *
 * These pages are created by plugins to allow them to display certain
 * full-page content without the user having to create a page for them.  For
 * example, a plugin could use this to create a dedicated page that would show
 * a list of all posts matching some sort of custom query generated by the plugin.
 *
 * Any page generated through this class will show up in the list of pages on
 * a user's blog.  However, all created pages will be marked as private by
 * default, preventing them from showing up in most auto-generated navigation
 * bars.  To make the pages visible, this class runs some startup code that
 * provides access to the created page at the last minute.
 *
 * For a plugin to register a page, the following code can be run:
 *
 *     $page_id = ClassBlogs_PluginPage::create_plugin_page( 'My Page' );
 *     echo 'A plugin page called "My Page" was created with an ID of ' . $page_id;
 *
 * @package ClassBlogs
 * @subpackage PluginPage
 * @since 0.2
 */
class ClassBlogs_PluginPage
{

	/**
	 * Registers a hook that will allow a user to view any private pages created
	 * by plugins using this class.
	 */
	public function __construct()
	{
		add_filter( 'posts_results', array( $this, '_allow_access_to_plugin_pages' ) );
	}

	/**
	 * Grants any user access to a private plugin page created using this class.
	 *
	 * This provides access only to the private pages created using the
	 * `create_plugin_page()` function, which creates a private page that should
	 * be accessible to any user.
	 *
	 * @param array $results the posts found when the page loaded
	 *
	 * @access private
	 * @since 0.2
	 */
	public function _allow_access_to_plugin_pages( $results )
	{
		// Abort if we have no private pages that need opening
		$pages = get_site_option( 'cb_plugin_pages' );
		if ( empty( $pages ) ) {
			return $results;
		}

		// If we have private pages and we're on one of them, make it temporarily
		// public and return its contents
		global $wpdb;
		foreach ( $pages as $page ) {
			if ( ClassBlogs_Utils::is_page( $page ) ) {
				$content = $wpdb->get_row( $wpdb->prepare ( "
					SELECT * FROM $wpdb->posts WHERE ID = %d",  $page ) );
				$content->comment_status = 'closed';
				$content->post_status = 'publish';
				return array( $content );
			}
		}
		return $results;
	}

	/**
	 * Adds a plugin page's ID to the list of pages that need to be opened
	 * if the page ID is not already in the registry.
	 *
	 * Pages are added to this list due to the fact that any page created through
	 * this class is by default marked as private, to prevent polluting any nav
	 * bars on the blog, and we need to maintain a list of created pages in order
	 * to grant access to the page if a user is trying to view it.
	 *
	 * @param int $page_id the ID of a plugin page
	 *
	 * @access private
	 * @since 0.2
	 */
	private static function _register_plugin_page( $page_id )
	{
		$plugin_pages = get_site_option( 'cb_plugin_pages', array() );
		if ( ! in_array( $page_id, $plugin_pages ) ) {
			$plugin_pages[] = $page_id;
			update_site_option( 'cb_plugin_pages', $plugin_pages );
		}
	}

	/**
	 * Creates a page for the plugin with the given name on the root blog.
	 *
	 * This makes a private page, so that it is not displayed by page-listing
	 * function of WordPress.  However, there is logic behind the scenes that
	 * grants any user access to the page when visiting its URL.
	 *
	 * An optional existing page ID can be passed in.  If this argument is given
	 * and the page ID does not map to a valid page, the page is recreated.  If
	 * the page ID represents an extant and valid page, however, no action is
	 * taken except for making sure that the page is registered in the list
	 * of plugin-created pages.
	 *
	 * @param  string $name    the name of the page to create
	 * @param  int    $page_id the optional ID of an already created page
	 * @return int             the ID of the created page
	 *
	 * @access protected
	 * @since 0.1
	 */
	public static function create_plugin_page( $name, $page_id = null )
	{
		$conflicts = true;
		$counter = 0;
		$page_name = $name;

		// If a page with the given ID already exists, abort early
		if ( get_page( $page_id ) ) {
			self::_register_plugin_page( $page_id );
			return $page_id;
		}

		// Find a name for the new page that doesn't conflict with others
		while ( $conflicts ) {
			$page = get_page_by_title( $page_name );
			if ( isset( $page ) ) {
				$counter++;
				$page_name = sprintf( '%s %d', $name, $counter );
			} else {
				$conflicts = false;
			}
		}

		// Create the new page and store its ID
		$new_page = array(
			'post_author' => ClassBlogs_Settings::get_admin_user_id(),
			'post_status' => 'private',
			'post_title'  => $page_name,
			'post_type'   => 'page' );
		$page_id = wp_insert_post( $new_page );
		self::_register_plugin_page( $page_id );

		return $page_id;
	}
}

ClassBlogs::register_plugin( 'plugin_page', new ClassBlogs_PluginPage() );

?>
